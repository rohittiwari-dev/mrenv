# TypeScript and IntelliSense Support

mrenv provides first-class TypeScript support with full type inference for your environment variables. This guide explains how to get the most out of TypeScript when using mrenv.

## Basic Type Inference

When you define your environment schema using Zod, TypeScript automatically infers the correct types for your environment variables:

```typescript
import { createEnv } from "mrenv";
import { z } from "zod";

const env = createEnv({
	server: {
		PORT: z.coerce.number(),
		DATABASE_URL: z.string().url(),
	},
	client: {
		NEXT_PUBLIC_API_URL: z.string().url(),
	},
});

// TypeScript knows these types automatically:
env.PORT; // number
env.DATABASE_URL; // string
env.NEXT_PUBLIC_API_URL; // string

// This would be a type error:
// const port: string = env.PORT; // Type 'number' is not assignable to type 'string'
```

## Simplified Type Inference with createTypedEnv

For the best IntelliSense experience, mrenv provides a `createTypedEnv` helper function that handles all the type complexity for you:

```typescript
import { createTypedEnv } from "mrenv";
import { z } from "zod";

// Define your schemas separately for better organization
const serverSchema = {
	PORT: z.coerce.number(),
	DATABASE_URL: z.string().url(),
};

const clientSchema = {
	NEXT_PUBLIC_API_URL: z.string().url(),
};

const sharedSchema = {
	NODE_ENV: z.enum(["development", "production", "test"]),
};

// Use the helper function for perfect IntelliSense
const env = createTypedEnv({
	server: serverSchema,
	client: clientSchema,
	shared: sharedSchema,
	// Other options...
});

// Now IntelliSense will provide perfect type information
env.PORT; // number
env.DATABASE_URL; // string
env.NEXT_PUBLIC_API_URL; // string
env.NODE_ENV; // "development" | "production" | "test"
```

## Enhanced IntelliSense with TypedEnv

If you need more control over your type definitions, you can use the `TypedEnv` helper type:

```typescript
import { createEnv, TypedEnv } from "mrenv";
import { z } from "zod";

// Define your schemas separately for better organization
const serverSchema = {
	PORT: z.coerce.number(),
	DATABASE_URL: z.string().url(),
};

const clientSchema = {
	NEXT_PUBLIC_API_URL: z.string().url(),
};

const sharedSchema = {
	NODE_ENV: z.enum(["development", "production", "test"]),
};

// Define the exact type for your environment
type Env = TypedEnv<
	typeof serverSchema,
	typeof clientSchema,
	typeof sharedSchema
>;

// Use the generic parameter in createEnv
const env = createEnv<{
	server: typeof serverSchema;
	client: typeof clientSchema;
	shared: typeof sharedSchema;
}>({
	server: serverSchema,
	client: clientSchema,
	shared: sharedSchema,
	// Other options...
});

// Now IntelliSense will provide perfect type information
env.PORT; // number
env.DATABASE_URL; // string
env.NEXT_PUBLIC_API_URL; // string
env.NODE_ENV; // "development" | "production" | "test"
```

## Type Safety for Frameworks

mrenv's adapter system ensures type safety across different environments:

```typescript
// For Next.js:
const env = createTypedEnv({
	// Schema definition...
	adapter: "next",
});

// In client components, this would cause a runtime error:
// env.SERVER_ONLY_VARIABLE

// For Node.js:
const env = createTypedEnv({
	// Schema definition...
	adapter: "node",
});

// In Node.js, all variables are accessible
```

## TypeScript with Schema Generation

When using the CLI to generate schemas, you can import the generated types:

```typescript
// Import the schema generated by CLI
import { envSchema } from "./env-schema";
import { createTypedEnv } from "mrenv";

// Use the helper function with the generated schema
const env = createTypedEnv({
	server: envSchema.server,
	client: envSchema.client,
	shared: envSchema.shared,
	// Other options...
});

// Perfect IntelliSense without any type casting
env.DATABASE_URL; // string
```

## Advanced Type Manipulation

You can create more sophisticated types using TypeScript's utility types:

```typescript
import { createTypedEnv, TypedEnv } from "mrenv";
import { z } from "zod";

// Define your schemas
const serverSchema = {
	DATABASE_URL: z.string().url(),
};

const clientSchema = {
	NEXT_PUBLIC_API_URL: z.string().url(),
};

// Create the environment
const env = createTypedEnv({
	server: serverSchema,
	client: clientSchema,
});

// Create a type for the environment
type Env = typeof env;

// Create a type that only includes client variables
type ClientEnv = Pick<Env, keyof typeof clientSchema>;

// Create a type that only includes server variables
type ServerEnv = Pick<Env, keyof typeof serverSchema>;
```

By following these patterns, you'll get excellent TypeScript support and IntelliSense when working with mrenv, making your environment variables fully type-safe throughout your application.
